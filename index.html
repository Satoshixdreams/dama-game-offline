<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>checkers game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        /* Styles inspired by the provided image */
        :root {
            --dark-bg: #100E19;
            --medium-bg: #201C2E;
            --light-elements: #F0F0F0;
            --accent-color: #5F4B8B;
            --board-bg: #201C2E;
            --square-light: #3D3454;
            --square-dark: #2C2541;
            --line-color: rgba(95, 75, 139, 0.5);
            --player1-color-start: #8A63D2;
            --player1-color-end: #5F4B8B;
            --player2-color-start: #4B3A6B;
            --player2-color-end: #2C2541;
            --selected-color: var(--accent-color);
            --king-indicator: #F0F0F0;
            --possible-move-color: rgba(95, 75, 139, 0.4);
            --capture-move-color: rgba(239, 68, 68, 0.4); /* Kept red for captures as it's a standard warning color */
            --must-capture-piece-color: rgba(251, 146, 60, 0.5);
            --button-bg-start: #5F4B8B;
            --button-bg-end: #5F4B8B;
            --button-hover-bg-start: #715A9E;
            --button-hover-bg-end: #715A9E;
            --button-accent-bg: var(--accent-color);
            --button-accent-hover-bg: #715A9E;
            --points-color: #a7f3d0;
            
        }
        /* Final color scheme from the new image */
        :root {
            --dark-bg: #1A1625;
            --medium-bg: #2C2A3A;
            --light-elements: #F0F0F0;
            --accent-color: #A08FFF;
            --board-bg: #2C2A3A;
            --square-light: #4C4863;
            --square-dark: #38354B;
            --line-color: rgba(160, 143, 255, 0.5);
            --player1-color-start: #6D63FF;
            --player1-color-end: #584FCF;
            --player2-color-start: #EAEAEA;
            --player2-color-end: #DCDCDC;
            --selected-color: #A08FFF;
            --king-indicator: #FFFFFF;
            --possible-move-color: rgba(0, 255, 221, 0.4);
            --capture-move-color: rgba(239, 68, 68, 0.4);
            --must-capture-piece-color: rgba(251, 146, 60, 0.5);
            --button-bg-start: #6D63FF;
            --button-bg-end: #584FCF;
            --button-hover-bg-start: #8177FF;
            --button-hover-bg-end: #6D63FF;
            --button-accent-bg: var(--accent-color);
            --button-accent-hover-bg: #B4A5FF;
            --points-color: #a7f3d0;
            
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background-color: var(--dark-bg); color: var(--light-elements); font-family: 'Inter', sans-serif;
            display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding: 0.75rem; gap: 0.75rem;
        }
        h1 { color: var(--light-elements); font-weight: 500; font-size: 1.25rem; text-align: center; }
        .game-setup, .game-info {
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 1rem;
            background-color: var(--medium-bg); padding: 1rem; border-radius: 0.75rem; width: 100%; max-width: 600px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .mode-selection { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; }
        .mode-selection label { margin-left: 0.5rem; text-align: center; }
        .mode-selection select {
            padding: 0.5rem 0.75rem; border-radius: 0.5rem; border: 1px solid var(--square-dark);
            background-color: var(--dark-bg); color: var(--light-elements); font-size: 0.8em; cursor: pointer;
        }
        .player-stats {
            background-color: rgba(0,0,0, 0.2); padding: 0.6rem 1rem; border-radius: 0.5rem;
            border: 1px solid var(--line-color); font-size: 0.8em; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .player-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-name {
            font-weight: bold;
        }

        .status-area {
            background-color: rgba(0,0,0, 0.2); padding: 0.6rem 1rem; border-radius: 0.5rem;
            border: 1px solid var(--line-color); font-size: 0.8em; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3); text-align: center;
            min-height: 2.5em; /* Prevents layout shift */
            display: flex; /* Centers text vertically */
            justify-content: center; /* Centers text horizontally */
            align-items: center; /* Centers text vertically */
        }
        .status-area { flex-grow: 1; }
        .player-stats { white-space: nowrap; }
        .player-stats span { margin: 0 0.3em; }
        .points { color: var(--points-color); font-weight: 500; }
        

        #board {
            display: grid; --square-size: clamp(28px, 11vw, 56px);
            grid-template-columns: repeat(8, var(--square-size)); grid-template-rows: repeat(8, var(--square-size));
            width: calc(8 * var(--square-size)); height: calc(8 * var(--square-size));
            background-color: var(--board-bg); border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            position: relative; overflow: hidden; border: 3px solid var(--medium-bg);
            flex-shrink: 0; /* Prevent board from shrinking */
        }
        .square { display: flex; justify-content: center; align-items: center; position: relative; }
        .square:nth-child(16n+2), .square:nth-child(16n+4), .square:nth-child(16n+6), .square:nth-child(16n+8),
        .square:nth-child(16n+9), .square:nth-child(16n+11), .square:nth-child(16n+13), .square:nth-child(16n+15) {
            background-color: var(--square-dark);
        }
        .square:nth-child(16n+1), .square:nth-child(16n+3), .square:nth-child(16n+5), .square:nth-child(16n+7),
        .square:nth-child(16n+10), .square:nth-child(16n+12), .square:nth-child(16n+14), .square:nth-child(16n+16) {
             background-color: var(--square-light);
        }
        .piece {
            width: 75%; height: 75%; border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center;
            box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3), 0 2px 3px rgba(0,0,0,0.2);
            transition: transform 0.2s ease-out, box-shadow 0.2s ease, background-image 0.3s; position: relative;
        }
        .piece:hover { transform: translateY(-2px); box-shadow: inset 0 -2px 4px rgba(0,0,0,0.3), 0 4px 8px rgba(0,0,0,0.3); }
        .piece.player1 { background-image: radial-gradient(circle at 50% 40%, var(--player1-color-start), var(--player1-color-end)); }
        .piece.player2 { background-image: radial-gradient(circle at 50% 40%, var(--player2-color-start), var(--player2-color-end)); color: var(--light-elements); }
        .piece.selected {
            box-shadow: 0 0 0 4px var(--selected-color), inset 0 -2px 4px rgba(0,0,0,0.3), 0 2px 3px rgba(0,0,0,0.2);
            transform: scale(1.05);
        }
        .piece.must-capture { box-shadow: 0 0 0 4px var(--must-capture-piece-color), inset 0 -2px 4px rgba(0,0,0,0.3), 0 2px 3px rgba(0,0,0,0.2); }
        .piece.king::after {
            content: 'ðŸ‘‘'; font-size: 50%; color: var(--king-indicator); position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%); text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .piece.player2.king::after { color: var(--king-indicator); }
        .possible-move::before, .capture-move::before {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40%; height: 40%; border-radius: 50%; opacity: 0.8; pointer-events: none;
        }
        .possible-move::before { background-color: var(--possible-move-color); box-shadow: 0 0 10px var(--possible-move-color); }
        .capture-move::before { background-color: var(--capture-move-color); box-shadow: 0 0 10px var(--capture-move-color); }
        button {
            padding: 0.75rem 1.5rem; border: none; border-radius: 0.5rem; font-size: 0.9rem; font-weight: 500;
            color: var(--light-elements); cursor: pointer; transition: background 0.3s ease, box-shadow 0.2s ease, transform 0.1s ease;
            background-image: linear-gradient(to bottom, var(--button-bg-start), var(--button-bg-end));
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button:hover { background-image: linear-gradient(to bottom, var(--button-hover-bg-start), var(--button-hover-bg-end)); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
        button:active { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        button.accent { background: var(--button-accent-bg); }
        button.accent:hover { background: var(--button-accent-hover-bg); }
        button:disabled {
            opacity: 0.5; cursor: not-allowed; background-image: none; background-color: var(--square-dark);
        }
        #win-message {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); color: white; padding: 2rem 3rem; border-radius: 1rem;
            text-align: center; z-index: 100; font-size: 1.5rem; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        #win-message button { margin-top: 1rem; }
        .thinking { pointer-events: none; opacity: 0.7; }

        .game-container { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; width: 100%; }

        .game-info, .game-setup { display: flex; flex-direction: column; gap: 0.75rem; width: 100%; max-width: 480px; }
        .sidebar { display: flex; flex-direction: column; gap: 0.75rem; width: 100%; max-width: 480px; }
        @media (min-width: 640px) {
            .game-container { flex-direction: row; align-items: flex-start; gap: 1rem; }
            .sidebar { max-width: 280px; }
        }
    </style>
</head>
<body>

    <h1>checkers game</h1>

    <div class="game-container">
        <div id="board"></div>
        <div class="game-info">
            <div class="status-area" id="statusArea">Initializing...</div>
            <div class="player-stats" id="playerStatsArea"></div>
        </div>
        <div class="game-setup">
            <div class="mode-selection">
                <label for="gameMode">Player vx Bot (Ai)</label>
                <select id="gameMode">
                    <option value="pvp">Player vs Player (PvP)</option>
                    <option value="pvc" selected>Player vx Bot (Ai)</option>
                </select>
            </div>
            <button id="newGameBtn" class="accent">New Game</button>
        </div>
    </div>

    

    <div id="win-message">
        <p id="win-text"></p>
        <button id="playAgainBtn" class="accent">Play Again</button>
    </div>

    <script>
        // ========================================================================
        // Part 1: Core Game Logic and UI
        // ========================================================================

        // DOM Elements
        const boardElement = document.getElementById('board');
        const statusArea = document.getElementById('statusArea');
        const playerStatsArea = document.getElementById('playerStatsArea');
        const newGameBtn = document.getElementById('newGameBtn');
        const gameModeSelect = document.getElementById('gameMode');
        const winMessageElement = document.getElementById('win-message');
        const winTextElement = document.getElementById('win-text');
        const playAgainBtn = document.getElementById('playAgainBtn');

        // Constants
        const BOARD_SIZE = 8;
        const EMPTY = 0;
        const P1_MAN = 1; const P2_MAN = 2; const P1_KING = 3; const P2_KING = 4;
        const AI_PLAYER = 2; const HUMAN_PLAYER = 1;
        

        // Game State Variables
        let board = []; let currentPlayer = HUMAN_PLAYER; let selectedPiece = null;
        let currentTurnMoves = []; let piecesThatMustCapture = []; let maxCaptureLength = 0;
        let isMidCaptureSequence = false; let player1PiecesCount = 16; let player2PiecesCount = 16;
        let player1Points = 0; let player2Points = 0; let gameOver = false;
        let gameMode = 'pvc'; let isComputerThinking = false;
        

        const POINTS_PER_CAPTURE = 1;

        // --- Game Initialization ---
        function initializeBoard() {
            console.log("--- New Game ---");
            gameMode = gameModeSelect.value; boardElement.innerHTML = '';
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(EMPTY));
            gameOver = false; isComputerThinking = false; boardElement.classList.remove('thinking');
            winMessageElement.style.display = 'none'; selectedPiece = null; currentTurnMoves = [];
            piecesThatMustCapture = []; maxCaptureLength = 0; isMidCaptureSequence = false;
            currentPlayer = HUMAN_PLAYER; player1PiecesCount = 16; player2PiecesCount = 16;
            player1Points = 0; player2Points = 0;
            // Don't reset connectedPlayerAddress here, keep it if already connected

            for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) {
                const square = document.createElement('div'); square.classList.add('square');
                square.dataset.row = r; square.dataset.col = c; let pieceType = EMPTY;
                if (r === 1 || r === 2) pieceType = P2_MAN; else if (r === 5 || r === 6) pieceType = P1_MAN;
                board[r][c] = pieceType; if (pieceType !== EMPTY) createPieceElement(pieceType, r, c, square);
                square.addEventListener('click', handleSquareClick); boardElement.appendChild(square); } }

            updatePlayerStatsDisplay(); // Update display including points
            calculateMovesForCurrentPlayer(); updateStatus();
            

            console.log("Board initialized. Mode:", gameMode, "Current Player:", currentPlayer);
        }

        // Creates piece DOM element
        function createPieceElement(pieceType, row, col, squareElement) { /* ... unchanged ... */
            const pieceElement = document.createElement('div'); pieceElement.classList.add('piece'); const player = getPlayer(pieceType); const isKing = (pieceType === P1_KING || pieceType === P2_KING); pieceElement.classList.add(`player${player}`); if (isKing) pieceElement.classList.add('king'); pieceElement.dataset.row = row; pieceElement.dataset.col = col; pieceElement.addEventListener('click', handlePieceClick); squareElement.appendChild(pieceElement); return pieceElement;
        }

        // --- User Interaction Handlers ---
        function handleSquareClick(event) { /* ... unchanged ... */
            if (gameOver || isComputerThinking || (gameMode === 'pvc' && currentPlayer === AI_PLAYER) || isMidCaptureSequence) return;
            const square = event.currentTarget; const row = parseInt(square.dataset.row); const col = parseInt(square.dataset.col);
            if (selectedPiece) { const move = currentTurnMoves.find(m => m.fromRow === selectedPiece.row && m.fromCol === selectedPiece.col && m.sequence[m.sequence.length - 1].toRow === row && m.sequence[m.sequence.length - 1].toCol === col); if (move) { if (maxCaptureLength > 0 && move.captureCount < maxCaptureLength) { setStatus("Error: you must choose the max capture move!"); return; } makeMove(move); } else { deselectPiece(); } }
        }
        function handlePieceClick(event) { /* ... unchanged ... */
            if (gameOver || isComputerThinking || (gameMode === 'pvc' && currentPlayer === AI_PLAYER)) return; event.stopPropagation(); const pieceElement = event.currentTarget; const row = parseInt(pieceElement.dataset.row); const col = parseInt(pieceElement.dataset.col); const pieceType = board[row][col]; const player = getPlayer(pieceType); if (player !== currentPlayer) { setStatus(`Not player ${player}'s turn`); return; } if (isMidCaptureSequence) { if (!(selectedPiece && selectedPiece.element === pieceElement)){ setStatus("Complete the current capture sequence."); return; } highlightPossibleMoves(currentTurnMoves); return; } if (maxCaptureLength > 0 && !piecesThatMustCapture.some(p => p.row === row && p.col === col)) { setStatus("You must choose a piece that can capture."); highlightPiecesThatMustCapture(); return; } if (selectedPiece && selectedPiece.element === pieceElement) { deselectPiece(); } else { selectPiece(pieceElement, row, col, pieceType); }
        }

        // --- Piece Selection Logic ---
        function selectPiece(pieceElement, row, col, pieceType) { /* ... unchanged ... */
            deselectPiece(); selectedPiece = { element: pieceElement, row, col, type: pieceType }; pieceElement.classList.add('selected'); const possibleMovesForThisPiece = currentTurnMoves.filter(move => move.fromRow === row && move.fromCol === col); highlightPossibleMoves(possibleMovesForThisPiece);
        }
        function deselectPiece() { /* ... unchanged ... */
            if (selectedPiece) { selectedPiece.element.classList.remove('selected'); } clearHighlights(); selectedPiece = null; if (maxCaptureLength > 0 && (currentPlayer === HUMAN_PLAYER || gameMode === 'pvp')) { highlightPiecesThatMustCapture(); }
        }

        // --- Move Calculation and Validation ---
        function calculateMovesForCurrentPlayer() { /* ... unchanged ... */
            console.log(`Calculating moves for Player ${currentPlayer}...`); const { availableMoves, mandatoryPieces, maxCaptures } = calculateValidMovesForPlayer(currentPlayer, board); currentTurnMoves = availableMoves; maxCaptureLength = maxCaptures; piecesThatMustCapture = mandatoryPieces; if(currentPlayer === HUMAN_PLAYER || gameMode === 'pvp') { highlightPiecesThatMustCapture(); } console.log(`Player ${currentPlayer} has ${availableMoves.length} valid moves. Max Capture: ${maxCaptures}`);
        }
        function calculateValidMovesForPlayer(player, boardState) { /* ... unchanged ... */
            let availableMoves = []; let mandatoryPieces = []; let currentMaxCapture = 0; let allPossibleSequences = []; for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { const pieceType = boardState[r][c]; if (getPlayer(pieceType) === player) { const sequences = findAllCaptureSequences(r, c, pieceType, boardState.map(row => [...row])); if (sequences.length > 0) { allPossibleSequences.push(...sequences); sequences.forEach(seq => { if (seq.captureCount > currentMaxCapture) currentMaxCapture = seq.captureCount; }); } } } } if (currentMaxCapture > 0) { availableMoves = allPossibleSequences.filter(seq => seq.captureCount === currentMaxCapture); mandatoryPieces = [...new Set(availableMoves.map(seq => `${seq.fromRow},${seq.fromCol}`))] .map(coord => ({ row: parseInt(coord.split(',')[0]), col: parseInt(coord.split(',')[1]) })); } else { for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { const pieceType = boardState[r][c]; if (getPlayer(pieceType) === player) { const moves = findNormalMoves(r, c, pieceType, boardState.map(row => [...row])); moves.forEach(move => availableMoves.push({ fromRow: r, fromCol: c, sequence: [move], captureCount: 0, boardAfter: null })); } } } mandatoryPieces = []; } return { availableMoves, mandatoryPieces, maxCaptures: currentMaxCapture };
        }

        // --- Helper Functions for Move Calculation (Core Logic - Unchanged) ---
        function getPlayer(pieceType) { if (pieceType === P1_MAN || pieceType === P1_KING) return 1; if (pieceType === P2_MAN || pieceType === P2_KING) return 2; return 0; }
        function getOpponent(player) { return player === 1 ? 2 : 1; }
        function isKing(pieceType) { return pieceType === P1_KING || pieceType === P2_KING; }
        function isValidSquare(row, col) { return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE; }
        function findAllCaptureSequences(startRow, startCol, pieceType, currentBoardState) { /* ... unchanged ... */ let sequences = []; let queue = [{ row: startRow, col: startCol, board: currentBoardState.map(r => [...r]), path: [], capturedCount: 0 }]; while (queue.length > 0) { const { row, col, board, path, capturedCount } = queue.shift(); let foundNextCapture = false; const singleCaptures = findSingleCapturesFrom(row, col, pieceType, board); for (const capture of singleCaptures) { foundNextCapture = true; const nextBoard = simulateMove(board, { fromRow: row, fromCol: col, ...capture, isCapture: true }); const newPath = [...path, capture]; queue.push({ row: capture.toRow, col: capture.toCol, board: nextBoard, path: newPath, capturedCount: capturedCount + 1 }); } if (!foundNextCapture && path.length > 0) { sequences.push({ fromRow: startRow, fromCol: startCol, sequence: path, captureCount: capturedCount, boardAfter: board }); } } return sequences; }
        function findSingleCapturesFrom(row, col, pieceType, boardState) { /* ... unchanged ... */ const captures = []; const player = getPlayer(pieceType); const opponentPlayer = getOpponent(player); if (!isKing(pieceType)) { const forwardDir = (player === 1) ? -1 : 1; const manDirections = [ { dr: forwardDir, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 } ]; for (const dir of manDirections) { const jR = row + dir.dr; const jC = col + dir.dc; const lR = row + 2 * dir.dr; const lC = col + 2 * dir.dc; if (isValidSquare(lR, lC) && boardState[lR][lC] === EMPTY) { if (isValidSquare(jR, jC)) { const jumpedPieceType = boardState[jR][jC]; if (getPlayer(jumpedPieceType) === opponentPlayer) { captures.push({ toRow: lR, toCol: lC, capturedRow: jR, capturedCol: jC }); } } } } } else { const directions = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }]; for (const dir of directions) { let jR = -1, jC = -1; for (let i = 1; ; i++) { const r = row + i * dir.dr; const c = col + i * dir.dc; if (!isValidSquare(r, c)) break; const currentPiece = boardState[r][c]; if (currentPiece !== EMPTY) { if (getPlayer(currentPiece) === opponentPlayer) { jR = r; jC = c; } break; } } if (jR !== -1) { for (let i = 1; ; i++) { const lR = jR + i * dir.dr; const lC = jC + i * dir.dc; if (!isValidSquare(lR, lC) || boardState[lR][lC] !== EMPTY) break; captures.push({ toRow: lR, toCol: lC, capturedRow: jR, capturedCol: jC }); } } } } return captures; }
        function findNormalMoves(row, col, pieceType, boardState) { /* ... unchanged ... */ const moves = []; const player = getPlayer(pieceType); if (!isKing(pieceType)) { const forwardDir = (player === 1) ? -1 : 1; const directions = [ { dr: forwardDir, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 } ]; for (const dir of directions) { const mR = row + dir.dr; const mC = col + dir.dc; if (isValidSquare(mR, mC) && boardState[mR][mC] === EMPTY) { moves.push({ toRow: mR, toCol: mC }); } } } else { const kingDirections = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }]; for (const dir of kingDirections) { for (let i = 1; ; i++) { const mR = row + i * dir.dr; const mC = col + i * dir.dc; if (!isValidSquare(mR, mC) || boardState[mR][mC] !== EMPTY) break; moves.push({ toRow: mR, toCol: mC }); } } } return moves; }
        function simulateMove(currentBoard, moveDetails) { /* ... unchanged ... */ let newBoard = currentBoard.map(row => [...row]); const { fromRow, fromCol, toRow, toCol, capturedRow, capturedCol, isCapture } = moveDetails; const pieceType = newBoard[fromRow][fromCol]; if(pieceType === EMPTY) { console.error("Simulate Move Error: Empty piece", fromRow, fromCol); return newBoard; } newBoard[toRow][toCol] = pieceType; newBoard[fromRow][fromCol] = EMPTY; if (isCapture && capturedRow !== undefined && capturedCol !== undefined) { if(isValidSquare(capturedRow, capturedCol)) newBoard[capturedRow][capturedCol] = EMPTY; else console.error("Simulate Move Error: Invalid captured square", capturedRow, capturedCol); } const player = getPlayer(pieceType); const promotionRank = (player === 1) ? 0 : BOARD_SIZE - 1; if (!isKing(pieceType) && toRow === promotionRank) { newBoard[toRow][toCol] = (player === 1) ? P1_KING : P2_KING; } return newBoard; }

        // --- UI Highlighting ---
        function highlightPossibleMoves(movesToHighlight) { /* ... unchanged ... */ clearHighlights(); movesToHighlight.forEach(move => { const targetStep = move.sequence[0]; const targetSquare = boardElement.querySelector(`.square[data-row='${targetStep.toRow}'][data-col='${targetStep.toCol}']`); if (targetSquare) { targetSquare.classList.add(move.captureCount > 0 ? 'capture-move' : 'possible-move'); } }); }
        function clearHighlights() { /* ... unchanged ... */ document.querySelectorAll('.possible-move, .capture-move').forEach(el => el.classList.remove('possible-move', 'capture-move')); }
        function highlightPiecesThatMustCapture() { /* ... unchanged ... */ document.querySelectorAll('.piece.must-capture').forEach(el => el.classList.remove('must-capture')); piecesThatMustCapture.forEach(p => { const pieceEl = boardElement.querySelector(`.piece[data-row='${p.row}'][data-col='${p.col}']`); if (pieceEl) pieceEl.classList.add('must-capture'); }); }

        // --- Move Execution (with points logic and ReferenceError fix) ---
        async function makeMove(move) {
            console.log(`Executing move: P${currentPlayer} from (${move.fromRow},${move.fromCol})`); // Log move execution start
            if (gameOver) return;
            const { fromRow, fromCol, sequence, captureCount } = move;
            let pieceElement = boardElement.querySelector(`.piece[data-row='${fromRow}'][data-col='${fromCol}']`);
            if (!pieceElement) { console.error("makeMove Error: Could not find piece element at", fromRow, fromCol); switchPlayer(); calculateMovesForCurrentPlayer(); checkGameOver(); return; }

            let currentPieceType = board[fromRow][fromCol];
            let currentRow = fromRow; let currentCol = fromCol;
            isMidCaptureSequence = (captureCount > 0 && sequence.length > 1);
            const wasComputerMove = (currentPlayer === AI_PLAYER && gameMode === 'pvc');
            const executingPlayer = currentPlayer;

            if (wasComputerMove || isMidCaptureSequence) boardElement.classList.add('thinking');

            let pointsEarnedThisTurn = 0;
            for (let i = 0; i < sequence.length; i++) {
                const step = sequence[i]; const { toRow, toCol, capturedRow, capturedCol } = step;
                board[toRow][toCol] = currentPieceType; board[currentRow][currentCol] = EMPTY;
                const targetSquare = boardElement.querySelector(`.square[data-row='${toRow}'][data-col='${toCol}']`);
                if (targetSquare) { targetSquare.appendChild(pieceElement); pieceElement.dataset.row = toRow; pieceElement.dataset.col = toCol; }
                else { console.error("makeMove Error: Target square not found for", toRow, toCol); gameOver = true; break; }
                if (captureCount > 0 && capturedRow !== undefined) {
                    const capturedType = board[capturedRow][capturedCol];
                    if(isValidSquare(capturedRow, capturedCol)) board[capturedRow][capturedCol] = EMPTY;
                    const capturedSquare = boardElement.querySelector(`.square[data-row='${capturedRow}'][data-col='${capturedCol}']`);
                    const capturedPieceElement = capturedSquare ? capturedSquare.querySelector('.piece') : null;
                    if (capturedPieceElement) {
                        capturedSquare.removeChild(capturedPieceElement);
                        const capturedPlayer = getPlayer(capturedType);
                        if (capturedPlayer === HUMAN_PLAYER) player1PiecesCount--;
                        else if (capturedPlayer === AI_PLAYER) player2PiecesCount--;
                        pointsEarnedThisTurn += POINTS_PER_CAPTURE;
                    }
                }
                currentRow = toRow; currentCol = toCol;
                // **FIX:** Call the correct function to update stats display
                updatePlayerStatsDisplay();
                if (isMidCaptureSequence && i < sequence.length - 1) { setStatus(wasComputerMove ? `Computer continues capture...` : `Continue capture...`); await sleep(400); }
            } // --- End of sequence steps loop ---

             // --- Update Total Points (Frontend Only) ---
             if (pointsEarnedThisTurn > 0) {
                 if (executingPlayer === HUMAN_PLAYER) { player1Points += pointsEarnedThisTurn; }
                 else { player2Points += pointsEarnedThisTurn; }
                 console.log(`Player ${executingPlayer} earned ${pointsEarnedThisTurn} points. Total: ${executingPlayer === 1 ? player1Points : player2Points}`);
                 updatePlayerStatsDisplay();
             }
             // -----------------------------------------

            // --- Post-sequence actions (Promotion checks unchanged) ---
            const finalRow = currentRow; const finalCol = currentCol; let justKinged = false;
            if (!isKing(currentPieceType)) { const player = getPlayer(currentPieceType); const promotionRank = (player === HUMAN_PLAYER) ? 0 : BOARD_SIZE - 1; if (finalRow === promotionRank) { currentPieceType = (player === HUMAN_PLAYER) ? P1_KING : P2_KING; board[finalRow][finalCol] = currentPieceType; pieceElement.classList.add('king'); justKinged = true; console.log(`Player ${player} promoted`); } }
            if (!isKing(currentPieceType)) { const player = getPlayer(currentPieceType); const pieceCount = (player === HUMAN_PLAYER) ? player1PiecesCount : player2PiecesCount; if (pieceCount === 1) { currentPieceType = (player === HUMAN_PLAYER) ? P1_KING : P2_KING; board[finalRow][finalCol] = currentPieceType; pieceElement.classList.add('king'); justKinged = true; console.log(`Player ${player}'s last piece promoted`); } }

            // --- End Turn Sequence ---
            deselectPiece(); isMidCaptureSequence = false;
            switchPlayer(); // Switch to the next player *before* calculating their moves
            calculateMovesForCurrentPlayer(); // Calculate moves for the player whose turn it now is

            if (!checkGameOver()) { // Check if the *new* current player has lost
                 updateStatus();
                 if (gameMode === 'pvc' && currentPlayer === AI_PLAYER && !gameOver) {
                     console.log("Handing turn to AI...");
                     setTimeout(triggerComputerMove, 200); // Trigger AI after short delay
                 } else {
                      // It's human's turn (or PvP), re-enable interaction
                      boardElement.classList.remove('thinking');
                      isComputerThinking = false;
                 }
             } else {
                 // Game is over
                 boardElement.classList.remove('thinking'); isComputerThinking = false;
                 updateStatus(); // Update status to show final win/loss message
                 const winner = getOpponent(currentPlayer); // Winner is the one whose opponent has no moves
                 console.log(`Game Over. Winner: Player ${winner}`);
                
             }
            updatePlayerStatsDisplay(); // Update stats display at the very end of the turn
        }


        function sleep(ms) { /* ... unchanged ... */ return new Promise(resolve => setTimeout(resolve, ms)); }

        // --- Player Turn and Status Updates ---
        function switchPlayer() { /* ... unchanged ... */ currentPlayer = getOpponent(currentPlayer); console.log("Switched player to:", currentPlayer); }
        function updateStatus(message = null) {
            if (gameOver) {
                const finalMsg = winTextElement.textContent;
                if (finalMsg) setStatus(finalMsg);
                return;
            }
            if (isComputerThinking) {
                setStatus("Computer is thinking...");
                return;
            }

            if (message) {
                setStatus(message);
            } else {
                let playerText = (gameMode === 'pvc' && currentPlayer === AI_PLAYER) ? "Computer" : `Player ${currentPlayer}`;
                let statusText = `Turn ${playerText}`;
                if (maxCaptureLength > 0) {
                    statusText += ` (Max capture is mandatory: ${maxCaptureLength} piece(s))`;
                }
                setStatus(statusText);
            }
        }

        function setStatus(message) {
            statusArea.textContent = message;
        }

        // Updated to display pieces AND points
        function updatePlayerStatsDisplay() {
            const p1Name = "Player 1";
            const p2Name = (gameMode === 'pvc') ? "Computer" : "Player 2";
            playerStatsArea.innerHTML = `
                <div class="player-stat">
                    <span class="player-name">${p1Name}</span>
                    <span class="stat-line">${player1PiecesCount} <i class="fas fa-chess-pawn"></i> / ${player1Points} points</span>
                </div>
                <div class="player-stat">
                    <span class="player-name">${p2Name}</span>
                    <span class="stat-line">${player2PiecesCount} <i class="fas fa-chess-pawn"></i> / ${player2Points} points</span>
                </div>
            `;
        }
        // Initial call
        updatePlayerStatsDisplay();


        // --- Game Over Check ---
        function checkGameOver() { /* ... unchanged ... */ if (gameOver) return true; if (player1PiecesCount <= 0) { endGame(AI_PLAYER); return true; } if (player2PiecesCount <= 0) { endGame(HUMAN_PLAYER); return true; } if (currentTurnMoves.length === 0) { console.log(`Game Over: Player ${currentPlayer} has no valid moves.`); endGame(getOpponent(currentPlayer)); return true; } if (player1PiecesCount === 1 && player2PiecesCount === 1) { const p1Piece = findFirstPieceOfType(P1_KING); const p2Piece = findFirstPieceOfType(P2_KING); if (p1Piece && p2Piece) { endGame('draw'); return true; } } return false; }
        function findFirstPieceOfType(type) { /* ... unchanged ... */ for (let r=0; r<8; r++) for(let c=0; c<8; c++) if(board[r][c]===type) return {r,c}; return null; }

        // --- End Game Display ---
        function endGame(winner) { /* ... unchanged ... */ if (gameOver) return; console.log("--- Game Over --- Winner:", winner); gameOver = true; isComputerThinking = false; boardElement.classList.remove('thinking'); let winnerText = ""; if (winner === 'draw') { winnerText = "Game ended in a draw!"; } else { let winnerName = (gameMode === 'pvc' && winner === AI_PLAYER) ? "Computer" : `Player ${winner}`; winnerText = `${winnerName} wins!`; } statusArea.textContent = winnerText; winTextElement.textContent = winnerText; winMessageElement.style.display = 'flex'; }

        // --- Event Listeners for Buttons ---
        newGameBtn.addEventListener('click', initializeBoard);
        playAgainBtn.addEventListener('click', initializeBoard);
        gameModeSelect.addEventListener('change', initializeBoard);

        // ØªÙ… Ø­Ø°Ù Ù…ÙŠØ²Ø§Øª Ø±Ø¨Ø· Ø§Ù„Ù…Ø­ÙØ¸Ø©

        
        // ========================================================================
        // Part 2: AI Logic (Bot) - Simplified Evaluation, More Logging
        // ========================================================================
        const AI_SEARCH_DEPTH = 3; // Adjust depth for difficulty/performance

        // --- AI Turn Trigger ---
        function triggerComputerMove() { /* ... unchanged ... */ if (gameOver || currentPlayer !== AI_PLAYER || gameMode !== 'pvc') { console.warn("AI Trigger: Conditions not met.", {gameOver, currentPlayer, gameMode}); isComputerThinking = false; boardElement.classList.remove('thinking'); return; } console.log("--- AI TURN START ---"); isComputerThinking = true; boardElement.classList.add('thinking'); updateStatus(); setTimeout(() => { const aiMoves = currentTurnMoves; if (aiMoves.length === 0) { console.log("AI has no moves. Game should be over."); isComputerThinking = false; boardElement.classList.remove('thinking'); updateStatus(); if (!gameOver) checkGameOver(); return; } console.log(`AI evaluating ${aiMoves.length} moves (Max Caps: ${maxCaptureLength}) at depth ${AI_SEARCH_DEPTH}...`); console.log("AI Available Moves:", aiMoves.map(m => `(${m.fromRow},${m.fromCol})->(${m.sequence[m.sequence.length-1].toRow},${m.sequence[m.sequence.length-1].toCol})[${m.captureCount}]`)); const bestMove = findBestMoveMinimax(board.map(r => [...r]), aiMoves, AI_SEARCH_DEPTH); if (bestMove) { const bestMoveSeq = bestMove.sequence[bestMove.sequence.length-1]; console.log(`AI CHOSE MOVE: (${bestMove.fromRow},${bestMove.fromCol}) -> (${bestMoveSeq.toRow},${bestMoveSeq.toCol}) Captures: ${bestMove.captureCount}`); const pieceElement = boardElement.querySelector(`.piece[data-row='${bestMove.fromRow}'][data-col='${bestMove.fromCol}']`); if(pieceElement) { pieceElement.classList.add('selected'); setTimeout(() => { if(pieceElement) pieceElement.classList.remove('selected'); console.log("AI calling makeMove..."); makeMove(bestMove); }, 250); } else { console.error("AI Error: Could not find piece element for best move."); makeMove(bestMove); } } else { console.error("AI Error: findBestMoveMinimax returned null! No move chosen."); if(aiMoves.length > 0){ console.log("AI making random fallback move."); makeMove(aiMoves[Math.floor(Math.random() * aiMoves.length)]); } else { console.error("AI Error: No moves available for fallback."); isComputerThinking = false; boardElement.classList.remove('thinking'); updateStatus("An error occurred in AI thinking."); if (!gameOver) checkGameOver(); } } }, 50); }
        function findBestMoveMinimax(currentBoardState, validMoves, depth) { /* ... unchanged ... */ console.log(`findBestMoveMinimax: Evaluating ${validMoves.length} moves, depth ${depth}`); let bestScore = -Infinity; let bestMoveFound = null; if (validMoves.length === 0) { console.error("findBestMoveMinimax: No valid moves provided!"); return null; } for (const move of validMoves) { let boardAfterMove = simulateSequence(currentBoardState, move); const score = minimaxRecursive(boardAfterMove, depth - 1, -Infinity, Infinity, false); const lastStep = move.sequence[move.sequence.length-1]; console.log(` -> Eval Root: (${move.fromRow},${move.fromCol})->(${lastStep.toRow},${lastStep.toCol}) Caps:${move.captureCount} Score:${score}`); if (bestMoveFound === null || score > bestScore) { bestScore = score; bestMoveFound = move; console.log(`    New best score at root: ${bestScore}`); } else if (score === bestScore && Math.random() < 0.3) { console.log(`    Equal score (${score}) at root, considering switch.`); bestMoveFound = move; } } console.log(`Minimax decision: Best Score = ${bestScore}`); if (!bestMoveFound && validMoves.length > 0) { console.warn("No move improved score, returning first valid move."); bestMoveFound = validMoves[0]; } else if (!bestMoveFound) { console.error("AI Critical Error: No best move found!"); } console.log("findBestMoveMinimax returning:", bestMoveFound ? `(${bestMoveFound.fromRow},${bestMoveFound.fromCol})->...[${bestMoveFound.captureCount}]` : null); return bestMoveFound; }
        function minimaxRecursive(boardState, depth, alpha, beta, isMaximizingPlayer) { /* ... unchanged ... */ const player = isMaximizingPlayer ? AI_PLAYER : HUMAN_PLAYER; if (isGameOverState(boardState, player)) { return evaluateBoard(boardState); } if (depth === 0) { return evaluateBoard(boardState); } const { availableMoves } = calculateValidMovesForPlayer(player, boardState); if (availableMoves.length === 0) { return isMaximizingPlayer ? (-100000 - depth) : (100000 + depth); } if (isMaximizingPlayer) { let maxEval = -Infinity; for (const move of availableMoves) { let boardAfterMove = simulateSequence(boardState, move); const evaluation = minimaxRecursive(boardAfterMove, depth - 1, alpha, beta, false); maxEval = Math.max(maxEval, evaluation); alpha = Math.max(alpha, evaluation); if (beta <= alpha) break; } return maxEval; } else { let minEval = Infinity; for (const move of availableMoves) { let boardAfterMove = simulateSequence(boardState, move); const evaluation = minimaxRecursive(boardAfterMove, depth - 1, alpha, beta, true); minEval = Math.min(minEval, evaluation); beta = Math.min(beta, evaluation); if (beta <= alpha) break; } return minEval; } }
        function simulateSequence(boardState, move) { /* ... unchanged ... */ let boardAfterMove = boardState.map(r => [...r]); let tempCurrentRow = move.fromRow; let tempCurrentCol = move.fromCol; for(const step of move.sequence) { const simDetails = { fromRow: tempCurrentRow, fromCol: tempCurrentCol, ...step, isCapture: move.captureCount > 0 }; boardAfterMove = simulateMove(boardAfterMove, simDetails); tempCurrentRow = step.toRow; tempCurrentCol = step.toCol; } const finalPieceType = boardAfterMove[tempCurrentRow][tempCurrentCol]; if (finalPieceType !== EMPTY && !isKing(finalPieceType)) { const player = getPlayer(finalPieceType); let pieceCount = 0; for(let r=0; r<BOARD_SIZE; r++) for(let c=0; c<BOARD_SIZE; c++) if(getPlayer(boardAfterMove[r][c]) === player) pieceCount++; if (pieceCount === 1) { boardAfterMove[tempCurrentRow][tempCurrentCol] = (player === 1) ? P1_KING : P2_KING; } } return boardAfterMove; }
        function isGameOverState(boardState, playerWhoseTurnItIs) { /* ... unchanged ... */ let p1C=0, p2C=0, p1K=0, p2K=0; for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const p=boardState[r][c]; if(getPlayer(p)===1){p1C++;if(isKing(p))p1K++;} else if(getPlayer(p)===2){p2C++;if(isKing(p))p2K++;}} if(p1C===0||p2C===0) return true; if(p1C===1&&p2C===1&&p1K===1&&p2K===1) return true; const {availableMoves}=calculateValidMovesForPlayer(playerWhoseTurnItIs, boardState); if(availableMoves.length===0) return true; return false; }
        function evaluateBoard(boardState) { /* ... unchanged ... */ let score=0; const KW=3.5; const AW=0.1; const WS=100000; const LS=-100000; let p1M=0,p1K=0,p2M=0,p2K=0; let p1A=0,p2A=0; let p1C=0,p2C=0; for(let r=0;r<8;r++) for(let c=0;c<8;c++){ const pt=boardState[r][c]; const p=getPlayer(pt); if(p===1){p1C++; if(isKing(pt)){p1K++;}else{p1M++; p1A+=(7-r);}} else if(p===2){p2C++; if(isKing(pt)){p2K++;}else{p2M++; p2A+=r;}}} if(p1C===0) return WS+p2C; if(p2C===0) return LS-p1C; let matScore=(p2M+p2K*KW)-(p1M+p1K*KW); let posScore=(p2A-p1A)*AW; score=matScore*100+posScore; return Number.isFinite(score)?score:0; }

        // --- Start Game on Load ---
        window.onload = initializeBoard;

</script>

<script type="module">
  import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk'
  window.addEventListener('load', async () => {
    try {
      await sdk.actions.ready()
    } catch (e) {}
  })
</script>

</body>
</html>
